# 第15章：多机器人系统

## 1. 多机器人系统概述

### 1.1 什么是多机器人系统

多机器人系统(Multi-robot Systems, MRS)是由多个机器人组成的系统，这些机器人协同工作以完成单个机器人难以或无法完成的任务。多机器人系统的核心在于机器人之间的协作与协调。

多机器人系统的主要特点：

- **可扩展性**：系统性能可以通过增加机器人数量来提高
- **鲁棒性**：单个机器人故障不会导致整个系统失效
- **灵活性**：可以根据任务需求动态调整系统配置
- **效率**：通过并行工作提高任务完成效率
- **功能互补**：不同类型的机器人可以提供互补的功能

### 1.2 多机器人系统的应用场景

多机器人系统在各个领域都有广泛的应用：

- **仓储物流**：多机器人协同搬运、分拣和配送
- **搜索与救援**：在灾难现场协同搜索幸存者
- **环境监测**：分布式传感器网络进行大范围环境监测
- **农业**：多机器人协同耕种、播种、除草和收获
- **军事应用**：无人机集群侦察和监视
- **建筑与施工**：多机器人协同建造复杂结构
- **太空探索**：多机器人协同探索行星表面

### 1.3 多机器人系统的挑战

设计和实现多机器人系统面临许多挑战：

- **通信**：确保机器人之间的可靠通信
- **协调**：有效协调多个机器人的行动
- **任务分配**：将任务高效地分配给适合的机器人
- **冲突解决**：处理资源竞争和潜在冲突
- **定位与导航**：在共享环境中的精确定位
- **容错**：处理机器人故障和通信中断
- **可扩展性**：系统设计需要支持大量机器人

## 2. ROS2中的分布式系统设计

### 2.1 ROS2分布式架构基础

ROS2的设计从一开始就考虑了分布式系统的需求，其基于DDS（数据分发服务）的通信中间件提供了强大的分布式通信能力。

#### 2.1.1 DDS与分布式系统

DDS（Data Distribution Service）是一个面向实时分布式系统的中间件标准，提供了发布-订阅模式的数据通信机制。DDS的关键特性包括：

- **发现机制**：自动发现网络中的参与者
- **QoS策略**：可配置的服务质量参数
- **数据中心设计**：以数据为中心而非以应用为中心
- **点对点通信**：无需中央服务器
- **可靠的多播**：高效的一对多通信

#### 2.1.2 ROS2的域ID和命名空间

ROS2使用域ID（Domain ID）和命名空间（Namespace）来隔离和组织分布式系统：

- **域ID**：将ROS2系统分隔成不同的通信域，不同域ID的节点无法直接通信
- **命名空间**：在同一域内进一步组织节点和话题

这两个机制对于多机器人系统尤为重要，可以用于：

- 隔离不同的机器人系统
- 防止命名冲突
- 组织复杂的多机器人拓扑结构

### 2.2 多机器人系统的ROS2网络配置

#### 2.2.1 网络设置

在多机器人系统中，正确配置网络是确保通信可靠性的关键：

```bash
# 设置ROS域ID（0-232之间的数字）
export ROS_DOMAIN_ID=5

# 设置ROS本地主机名（在多机器人系统中很重要）
export ROS_LOCALHOST_ONLY=0

# 选择DDS实现（可能影响分布式性能）
export RMW_IMPLEMENTATION=rmw_cyclonedds_cpp
```

#### 2.2.2 多机器人命名空间策略

在多机器人系统中，合理的命名空间策略至关重要：

1. **基于机器人的命名空间**：
   ```
   /robot1/...
   /robot2/...
   ```

2. **基于功能的命名空间**：
   ```
   /navigation/robot1/...
   /navigation/robot2/...
   ```

3. **混合策略**：
   ```
   /robot1/navigation/...
   /robot1/manipulation/...
   ```

#### 2.2.3 多机器人系统的启动文件

使用ROS2的启动文件可以简化多机器人系统的部署：

```python
from launch import LaunchDescription
from launch_ros.actions import Node

def generate_launch_description():
    return LaunchDescription([
        # 机器人1的节点
        Node(
            package='robot_package',
            executable='robot_node',
            namespace='robot1',
            parameters=[{'robot_id': 1}],
        ),
        # 机器人2的节点
        Node(
            package='robot_package',
            executable='robot_node',
            namespace='robot2',
            parameters=[{'robot_id': 2}],
        ),
        # 中央协调节点
        Node(
            package='coordination_package',
            executable='coordinator_node',
            name='system_coordinator',
        )
    ])
```

## 3. 多机器人通信和协调

### 3.1 多机器人通信模式

在多机器人系统中，有几种主要的通信模式：

#### 3.1.1 点对点通信

点对点通信是两个机器人之间的直接通信：

```python
# 在机器人1上创建客户端
self.client = self.create_client(SomeService, '/robot2/some_service')

# 在机器人2上创建服务
self.service = self.create_service(SomeService, 'some_service', self.service_callback)
```

#### 3.1.2 广播通信

广播通信允许一个机器人向所有其他机器人发送消息：

```python
# 创建广播发布者
self.publisher = self.create_publisher(BroadcastMsg, '/fleet/broadcast', 10)

# 在每个机器人上创建订阅者
self.subscription = self.create_subscription(
    BroadcastMsg, '/fleet/broadcast', self.broadcast_callback, 10)
```

#### 3.1.3 组通信

组通信允许向特定组的机器人发送消息：

```python
# 创建组发布者
self.publisher = self.create_publisher(
    GroupMsg, '/fleet/group1/messages', 10)

# 在组内的机器人上创建订阅者
self.subscription = self.create_subscription(
    GroupMsg, '/fleet/group1/messages', self.group_callback, 10)
```

### 3.2 分布式协调算法

#### 3.2.1 领导者选举

在多机器人系统中，领导者选举是一种常见的协调机制：

```python
class LeaderElection(Node):
    def __init__(self):
        super().__init__('leader_election')
        self.robot_id = self.declare_parameter('robot_id', 0).value
        self.is_leader = False
        self.highest_id_seen = self.robot_id
        
        # 发布自己的ID
        self.id_publisher = self.create_publisher(
            Int32, '/fleet/leader_election/ids', 10)
        
        # 监听其他机器人的ID
        self.id_subscription = self.create_subscription(
            Int32, '/fleet/leader_election/ids', self.id_callback, 10)
        
        # 定期发布ID
        self.timer = self.create_timer(1.0, self.publish_id)
    
    def publish_id(self):
        msg = Int32()
        msg.data = self.robot_id
        self.id_publisher.publish(msg)
    
    def id_callback(self, msg):
        if msg.data > self.highest_id_seen:
            self.highest_id_seen = msg.data
            self.is_leader = False
        elif msg.data == self.robot_id:
            self.is_leader = (self.robot_id == self.highest_id_seen)
```

#### 3.2.2 共识算法

共识算法用于让多个机器人就某个值达成一致：

```python
class ConsensusNode(Node):
    def __init__(self):
        super().__init__('consensus_node')
        self.robot_id = self.declare_parameter('robot_id', 0).value
        self.value = self.declare_parameter('initial_value', 0.0).value
        self.round = 0
        self.values = {self.robot_id: self.value}
        
        # 发布自己的值
        self.value_publisher = self.create_publisher(
            ConsensusMsg, '/fleet/consensus/values', 10)
        
        # 监听其他机器人的值
        self.value_subscription = self.create_subscription(
            ConsensusMsg, '/fleet/consensus/values', self.value_callback, 10)
        
        # 定期发布值并更新
        self.timer = self.create_timer(1.0, self.consensus_step)
    
    def consensus_step(self):
        # 发布当前值
        msg = ConsensusMsg()
        msg.robot_id = self.robot_id
        msg.value = self.value
        msg.round = self.round
        self.value_publisher.publish(msg)
        
        # 如果收集了足够的值，计算平均值
        if len(self.values) > 0:
            self.value = sum(self.values.values()) / len(self.values)
            self.round += 1
            self.get_logger().info(f'Round {self.round}, new value: {self.value}')
    
    def value_callback(self, msg):
        if msg.round == self.round:
            self.values[msg.robot_id] = msg.value
```

### 3.3 冲突解决策略

#### 3.3.1 资源分配

在多机器人系统中，资源分配是一个常见的冲突：

```python
class ResourceManager(Node):
    def __init__(self):
        super().__init__('resource_manager')
        self.resources = {}
        self.locks = {}
        
        # 资源请求服务
        self.request_service = self.create_service(
            ResourceRequest, 'request_resource', self.handle_request)
        
        # 资源释放服务
        self.release_service = self.create_service(
            ResourceRelease, 'release_resource', self.handle_release)
    
    def handle_request(self, request, response):
        resource_id = request.resource_id
        robot_id = request.robot_id
        
        # 检查资源是否可用
        if resource_id not in self.locks or self.locks[resource_id] == robot_id:
            self.locks[resource_id] = robot_id
            response.success = True
        else:
            response.success = False
        
        return response
    
    def handle_release(self, request, response):
        resource_id = request.resource_id
        robot_id = request.robot_id
        
        # 只有锁定资源的机器人可以释放它
        if resource_id in self.locks and self.locks[resource_id] == robot_id:
            del self.locks[resource_id]
            response.success = True
        else:
            response.success = False
        
        return response
```

#### 3.3.2 路径规划冲突

多机器人系统中的路径规划冲突可以通过优先级或时间窗口方法解决：

```python
class PathCoordinator(Node):
    def __init__(self):
        super().__init__('path_coordinator')
        self.robot_id = self.declare_parameter('robot_id', 0).value
        self.priority = self.declare_parameter('priority', 0).value
        self.path = []
        self.time_windows = {}
        
        # 发布路径计划
        self.path_publisher = self.create_publisher(
            PathPlan, '/fleet/path_coordination/plans', 10)
        
        # 监听其他机器人的路径计划
        self.path_subscription = self.create_subscription(
            PathPlan, '/fleet/path_coordination/plans', self.path_callback, 10)
    
    def publish_path(self, path):
        self.path = path
        msg = PathPlan()
        msg.robot_id = self.robot_id
        msg.priority = self.priority
        msg.path = path
        self.path_publisher.publish(msg)
    
    def path_callback(self, msg):
        other_robot_id = msg.robot_id
        other_priority = msg.priority
        other_path = msg.path
        
        # 检测路径冲突
        conflicts = self.detect_conflicts(self.path, other_path)
        
        if conflicts:
            # 基于优先级解决冲突
            if self.priority < other_priority:
                # 重新规划路径
                self.replan_path(conflicts, other_path)
            # 或者使用时间窗口方法
            else:
                self.assign_time_windows(conflicts, other_robot_id, other_path)
    
    def detect_conflicts(self, path1, path2):
        # 实现冲突检测逻辑
        pass
    
    def replan_path(self, conflicts, other_path):
        # 实现路径重规划逻辑
        pass
    
    def assign_time_windows(self, conflicts, other_robot_id, other_path):
        # 实现时间窗口分配逻辑
        pass
```

## 4. 多机器人任务分配

### 4.1 任务分配问题

多机器人任务分配是指将一组任务高效地分配给多个机器人，使得整体性能最优。这是多机器人系统中的核心问题之一。

任务分配问题可以形式化为：

- 一组机器人 R = {r₁, r₂, ..., rₙ}
- 一组任务 T = {t₁, t₂, ..., tₘ}
- 一个成本函数 C(rᵢ, tⱼ)，表示机器人 rᵢ 执行任务 tⱼ 的成本
- 目标：找到一个分配方案，使总成本最小

### 4.2 集中式任务分配

集中式任务分配由一个中央协调器负责所有决策：

```python
class CentralizedTaskAllocator(Node):
    def __init__(self):
        super().__init__('centralized_task_allocator')
        self.robots = {}
        self.tasks = {}
        self.allocations = {}
        
        # 注册机器人服务
        self.register_service = self.create_service(
            RegisterRobot, 'register_robot', self.register_robot_callback)
        
        # 添加任务服务
        self.add_task_service = self.create_service(
            AddTask, 'add_task', self.add_task_callback)
        
        # 分配任务服务
        self.allocate_service = self.create_service(
            AllocateTasks, 'allocate_tasks', self.allocate_tasks_callback)
        
        # 任务完成服务
        self.complete_service = self.create_service(
            CompleteTask, 'complete_task', self.complete_task_callback)
    
    def register_robot_callback(self, request, response):
        robot_id = request.robot_id
        capabilities = request.capabilities
        position = request.position
        
        self.robots[robot_id] = {
            'capabilities': capabilities,
            'position': position,
            'status': 'idle'
        }
        
        response.success = True
        return response
    
    def add_task_callback(self, request, response):
        task_id = request.task_id
        task_type = request.task_type
        position = request.position
        priority = request.priority
        
        self.tasks[task_id] = {
            'type': task_type,
            'position': position,
            'priority': priority,
            'status': 'pending'
        }
        
        response.success = True
        return response
    
    def allocate_tasks_callback(self, request, response):
        # 实现任务分配算法（如匈牙利算法）
        allocations = self.hungarian_algorithm(self.robots, self.tasks)
        
        # 更新分配结果
        self.allocations.update(allocations)
        
        # 准备响应
        response.allocations = [
            TaskAllocation(robot_id=r_id, task_id=t_id)
            for r_id, t_id in allocations.items()
        ]
        
        return response
    
    def complete_task_callback(self, request, response):
        robot_id = request.robot_id
        task_id = request.task_id
        
        if task_id in self.tasks and self.allocations.get(robot_id) == task_id:
            self.tasks[task_id]['status'] = 'completed'
            self.robots[robot_id]['status'] = 'idle'
            del self.allocations[robot_id]
            response.success = True
        else:
            response.success = False
        
        return response
    
    def hungarian_algorithm(self, robots, tasks):
        # 匈牙利算法实现
        # 这里简化处理，实际实现需要构建成本矩阵并求解
        allocations = {}
        available_robots = list(robots.keys())
        pending_tasks = [t_id for t_id, t in tasks.items() if t['status'] == 'pending']
        
        for task_id in pending_tasks:
            if available_robots:
                # 简单贪心：分配给第一个可用机器人
                robot_id = available_robots.pop(0)
                allocations[robot_id] = task_id
                self.robots[robot_id]['status'] = 'busy'
                self.tasks[task_id]['status'] = 'allocated'
        
        return allocations
```

### 4.3 分布式任务分配

分布式任务分配让每个机器人参与决策过程：

```python
class DistributedTaskAllocator(Node):
    def __init__(self):
        super().__init__('distributed_task_allocator')
        self.robot_id = self.declare_parameter('robot_id', 0).value
        self.position = [0.0, 0.0]  # 初始位置
        self.capabilities = []  # 机器人能力
        self.current_task = None
        self.bid_values = {}
        
        # 任务公告订阅
        self.task_sub = self.create_subscription(
            TaskAnnouncement, '/fleet/tasks/announcements', 
            self.task_announcement_callback, 10)
        
        # 出价发布
        self.bid_pub = self.create_publisher(
            TaskBid, '/fleet/tasks/bids', 10)
        
        # 任务分配订阅
        self.allocation_sub = self.create_subscription(
            TaskAllocation, '/fleet/tasks/allocations', 
            self.allocation_callback, 10)
        
        # 位置更新定时器
        self.timer = self.create_timer(1.0, self.update_position)
    
    def update_position(self):
        # 更新机器人位置（在实际系统中，这将从定位系统获取）
        if self.current_task:
            # 向任务位置移动
            task_pos = self.current_task['position']
            # 简化的移动逻辑
            dx = task_pos[0] - self.position[0]
            dy = task_pos[1] - self.position[1]
            dist = (dx**2 + dy**2)**0.5
            
            if dist < 0.1:  # 到达任务位置
                self.complete_task()
            else:
                # 向任务移动
                step = min(0.1, dist)
                self.position[0] += (dx / dist) * step
                self.position[1] += (dy / dist) * step
    
    def task_announcement_callback(self, msg):
        task_id = msg.task_id
        task_type = msg.task_type
        task_position = msg.position
        
        # 检查是否有能力执行此任务
        if task_type in self.capabilities:
            # 计算出价（基于距离）
            dx = task_position[0] - self.position[0]
            dy = task_position[1] - self.position[1]
            distance = (dx**2 + dy**2)**0.5
            bid_value = 1.0 / (1.0 + distance)  # 距离越近，出价越高
            
            # 发布出价
            bid_msg = TaskBid()
            bid_msg.robot_id = self.robot_id
            bid_msg.task_id = task_id
            bid_msg.bid_value = bid_value
            self.bid_pub.publish(bid_msg)
            
            # 记录出价
            self.bid_values[task_id] = bid_value
    
    def allocation_callback(self, msg):
        if self.is_auctioneer or msg.robot_id != self.robot_id:
            return
            
        task_id = msg.task_id
        self.get_logger().info(f'Won auction for task: {task_id}')
        # 处理任务分配
```

### 4.4 市场机制任务分配

市场机制使用拍卖等方法进行任务分配：

```python
class AuctionTaskAllocator(Node):
    def __init__(self):
        super().__init__('auction_task_allocator')
        self.is_auctioneer = self.declare_parameter('is_auctioneer', False).value
        self.robot_id = self.declare_parameter('robot_id', 0).value
        
        if self.is_auctioneer:
            # 拍卖者逻辑
            self.tasks = {}
            self.bids = {}
            self.auction_timer = self.create_timer(5.0, self.start_auction)
            
            # 添加任务服务
            self.add_task_service = self.create_service(
                AddTask, 'add_task', self.add_task_callback)
            
            # 接收出价订阅
            self.bid_sub = self.create_subscription(
                TaskBid, '/fleet/auction/bids', self.bid_callback, 10)
            
            # 分配结果发布
            self.allocation_pub = self.create_publisher(
                TaskAllocation, '/fleet/auction/allocations', 10)
        else:
            # 投标者逻辑
            self.position = [0.0, 0.0]
            self.capabilities = []
            
            # 拍卖公告订阅
            self.auction_sub = self.create_subscription(
                AuctionAnnouncement, '/fleet/auction/announcements', 
                self.auction_callback, 10)
            
            # 出价发布
            self.bid_pub = self.create_publisher(
                TaskBid, '/fleet/auction/bids', 10)
            
            # 分配结果订阅
            self.allocation_sub = self.create_subscription(
                TaskAllocation, '/fleet/auction/allocations', 
                self.allocation_callback, 10)
    
    # 拍卖者方法
    def add_task_callback(self, request, response):
        if self.is_auctioneer:
            task_id = request.task_id
            self.tasks[task_id] = {
                'type': request.task_type,
                'position': request.position,
                'priority': request.priority,
                'status': 'pending'
            }
            response.success = True
        else:
            response.success = False
        return response
    
    def start_auction(self):
        if not self.is_auctioneer:
            return
            
        pending_tasks = [t_id for t_id, t in self.tasks.items() 
                        if t['status'] == 'pending']
        
        if not pending_tasks:
            return
            
        # 为每个待处理任务启动拍卖
        for task_id in pending_tasks:
            self.bids[task_id] = []
            
            # 发布拍卖公告
            announce_msg = AuctionAnnouncement()
            announce_msg.task_id = task_id
            announce_msg.task_type = self.tasks[task_id]['type']
            announce_msg.position = self.tasks[task_id]['position']
            announce_msg.auction_duration = 2.0  # 2秒拍卖时间
            
            # 这里需要一个发布者，简化起见省略
            
            # 设置定时器来结束拍卖
            self.create_timer(
                2.0, lambda t_id=task_id: self.end_auction(t_id), 
                oneshot=True)
    
    def bid_callback(self, msg):
        if not self.is_auctioneer:
            return
            
        task_id = msg.task_id
        robot_id = msg.robot_id
        bid_value = msg.bid_value
        
        if task_id in self.bids:
            self.bids[task_id].append((robot_id, bid_value))
    
    def end_auction(self, task_id):
        if not self.is_auctioneer or task_id not in self.bids:
            return
            
        bids = self.bids[task_id]
        if not bids:
            return
            
        # 找出最高出价
        winner_id, highest_bid = max(bids, key=lambda x: x[1])
        
        # 发布分配结果
        alloc_msg = TaskAllocation()
        alloc_msg.robot_id = winner_id
        alloc_msg.task_id = task_id
        alloc_msg.task_position = self.tasks[task_id]['position']
        self.allocation_pub.publish(alloc_msg)
        
        # 更新任务状态
        self.tasks[task_id]['status'] = 'allocated'
        
        # 清理出价记录
        del self.bids[task_id]
    
    # 投标者方法
    def auction_callback(self, msg):
        if self.is_auctioneer:
            return
            
        task_id = msg.task_id
        task_type = msg.task_type
        task_position = msg.position
        
        # 检查能力并计算出价
        if task_type in self.capabilities:
            dx = task_position[0] - self.position[0]
            dy = task_position[1] - self.position[1]
            distance = (dx**2 + dy**2)**0.5
            
            # 出价策略：距离越近，出价越高
            bid_value = 1.0 / (1.0 + distance)
            
            # 发布出价
            bid_msg = TaskBid()
            bid_msg.robot_id = self.robot_id
            bid_msg.task_id = task_id
            bid_msg.bid_value = bid_value
            self.bid_pub.publish(bid_msg)
    
    def allocation_callback(self, msg):
        if self.is_auctioneer or msg.robot_id != self.robot_id:
            return
            
        task_id = msg.task_id
        self.get_logger().info(f'Won auction for task: {task_id}')
        # 处理任务分配
```

## 5. 多机器人系统的实际应用
多机器人系统已经在多个领域展现出巨大的应用潜力，下面介绍几个典型的应用场景。

### 5.1 市场机制任务分配

在仓储物流领域，多机器人系统能够协同工作，提高仓库的运作效率：
```python
class WarehouseRobot(Node):
    def __init__(self):
        super().__init__('warehouse_robot')
        self.robot_id = self.declare_parameter('robot_id', 0).value
        self.position = [0.0, 0.0]
        self.status = 'idle'  # idle, moving, picking, delivering
        self.current_task = None
        
        # 任务订阅
        self.task_sub = self.create_subscription(
            WarehouseTask, '/warehouse/tasks', self.task_callback, 10)
        
        # 状态发布
        self.status_pub = self.create_publisher(
            RobotStatus, '/warehouse/robot_status', 10)
        
        # 定期发布状态
        self.timer = self.create_timer(1.0, self.publish_status)
        
        # 避障服务客户端
        self.collision_client = self.create_client(
            CollisionCheck, '/warehouse/collision_check')
    
    def task_callback(self, msg):
        if self.status != 'idle' or msg.assigned_robot_id != self.robot_id:
            return
            
        self.current_task = {
            'id': msg.task_id,
            'type': msg.task_type,
            'source': msg.source_location,
            'destination': msg.destination_location,
            'item_id': msg.item_id
        }
        
        self.status = 'moving'
        self.get_logger().info(f'Received task {msg.task_id}, moving to source')
        
        # 开始执行任务
        self.execute_task()
    
    def publish_status(self):
        msg = RobotStatus()
        msg.robot_id = self.robot_id
        msg.position = self.position
        msg.status = self.status
        msg.battery_level = 85.0  # 模拟电池电量
        
        if self.current_task:
            msg.current_task_id = self.current_task['id']
        
        self.status_pub.publish(msg)
    
    def execute_task(self):
        # 这里应该包含路径规划和执行的代码
        # 简化起见，我们只模拟状态变化
        
        # 检查路径是否有碰撞
        self.check_collision_path(self.position, self.current_task['source'])
        
        # 模拟移动到源位置
        self.get_logger().info(f'Moving to source location {self.current_task["source"]}')
        # ... 移动逻辑 ...
        
        # 到达源位置后，更新状态
        self.status = 'picking'
        self.position = self.current_task['source']
        self.get_logger().info(f'Picking item {self.current_task["item_id"]}')
        
        # 模拟拾取物品
        # ... 拾取逻辑 ...
        
        # 检查到目的地的路径
        self.check_collision_path(self.position, self.current_task['destination'])
        
        # 拾取后，移动到目的地
        self.status = 'moving'
        self.get_logger().info(f'Moving to destination {self.current_task["destination"]}')
        # ... 移动逻辑 ...
        
        # 到达目的地，更新状态
        self.status = 'delivering'
        self.position = self.current_task['destination']
        self.get_logger().info(f'Delivering item {self.current_task["item_id"]}')
        
        # 模拟交付物品
        # ... 交付逻辑 ...
        
        # 任务完成
        self.status = 'idle'
        self.current_task = None
        self.get_logger().info('Task completed, waiting for new task')
    
    def check_collision_path(self, start, end):
        # 创建碰撞检查请求
        request = CollisionCheck.Request()
        request.robot_id = self.robot_id
        request.start_position = start
        request.end_position = end
        
        # 调用服务
        future = self.collision_client.call_async(request)
        rclpy.spin_until_future_complete(self, future)
        
        response = future.result()
        if response.collision_detected:
            self.get_logger().warning(f'Collision detected with robot {response.colliding_robot_id}')
            # 处理碰撞情况
            # ... 碰撞处理逻辑 ...
```

### 5.2 搜索与救援
在搜索与救援任务中，多机器人系统可以协同探索未知环境，提高搜索效率：
```python
class SearchRescueRobot(Node):
    def __init__(self):
        super().__init__('search_rescue_robot')
        self.robot_id = self.declare_parameter('robot_id', 0).value
        self.position = [0.0, 0.0]
        self.explored_areas = set()
        self.detected_victims = []
        
        # 地图共享发布者
        self.map_pub = self.create_publisher(
            ExplorationMap, '/search_rescue/maps', 10)
        
        # 接收其他机器人的地图
        self.map_sub = self.create_subscription(
            ExplorationMap, '/search_rescue/maps', self.map_callback, 10)
        
        # 受害者发现发布
        self.victim_pub = self.create_publisher(
            VictimDetection, '/search_rescue/victims', 10)
        
        # 接收其他机器人的受害者发现
        self.victim_sub = self.create_subscription(
            VictimDetection, '/search_rescue/victims', self.victim_callback, 10)
        
        # 任务分配订阅
        self.task_sub = self.create_subscription(
            ExplorationTask, '/search_rescue/tasks', self.task_callback, 10)
        
        # 定期探索和发布地图
        self.explore_timer = self.create_timer(5.0, self.explore)
        self.map_timer = self.create_timer(2.0, self.publish_map)
    
    def explore(self):
        # 获取下一个探索点
        next_point = self.get_next_exploration_point()
        
        # 模拟移动到下一个点
        self.get_logger().info(f'Moving to exploration point {next_point}')
        self.position = next_point
        
        # 模拟探索该区域
        self.explored_areas.add((int(next_point[0]), int(next_point[1])))
        
        # 模拟检测受害者
        if random.random() < 0.1:  # 10%的概率发现受害者
            victim_id = len(self.detected_victims) + 1
            victim_position = [
                next_point[0] + random.uniform(-0.5, 0.5),
                next_point[1] + random.uniform(-0.5, 0.5)
            ]
            victim_status = random.choice(['stable', 'critical', 'deceased'])
            
            self.detected_victims.append({
                'id': victim_id,
                'position': victim_position,
                'status': victim_status,
                'detected_by': self.robot_id
            })
            
            # 发布受害者信息
            self.publish_victim(victim_id, victim_position, victim_status)
    
    def get_next_exploration_point(self):
        # 实际应用中，这应该使用更复杂的算法
        # 考虑已探索区域、其他机器人的位置等
        
        # 简化起见，我们随机选择一个未探索的相邻区域
        current_x, current_y = int(self.position[0]), int(self.position[1])
        
        # 可能的移动方向
        directions = [
            (1, 0), (-1, 0), (0, 1), (0, -1),
            (1, 1), (1, -1), (-1, 1), (-1, -1)
        ]
        
        # 过滤掉已探索的区域
        candidates = []
        for dx, dy in directions:
            new_x, new_y = current_x + dx, current_y + dy
            if (new_x, new_y) not in self.explored_areas:
                candidates.append((new_x, new_y))
        
        if candidates:
            return random.choice(candidates)
        else:
            # 如果所有相邻区域都已探索，随机移动
            dx, dy = random.choice(directions)
            return [current_x + dx, current_y + dy]
    
    def publish_map(self):
        # 创建并发布地图消息
        msg = ExplorationMap()
        msg.robot_id = self.robot_id
        msg.timestamp = self.get_clock().now().to_msg()
        
        # 将探索区域转换为消息格式
        for x, y in self.explored_areas:
            msg.explored_cells.append(Cell(x=x, y=y))
        
        self.map_pub.publish(msg)
    
    def publish_victim(self, victim_id, position, status):
        msg = VictimDetection()
        msg.robot_id = self.robot_id
        msg.victim_id = victim_id
        msg.position = position
        msg.status = status
        msg.timestamp = self.get_clock().now().to_msg()
        
        self.victim_pub.publish(msg)
        self.get_logger().info(f'Detected victim {victim_id} at {position} with status {status}')
    
    def map_callback(self, msg):
        if msg.robot_id == self.robot_id:
            return  # 忽略自己的地图
        
        # 合并其他机器人的地图
        for cell in msg.explored_cells:
            self.explored_areas.add((cell.x, cell.y))
    
    def victim_callback(self, msg):
        if msg.robot_id == self.robot_id:
            return  # 忽略自己的发现
        
        # 检查是否已知此受害者
        for victim in self.detected_victims:
            if victim['position'][0] == msg.position[0] and victim['position'][1] == msg.position[1]:
                return  # 已知受害者，忽略
        
        # 添加新发现的受害者
        self.detected_victims.append({
            'id': msg.victim_id,
            'position': msg.position,
            'status': msg.status,
            'detected_by': msg.robot_id
        })
    
    def task_callback(self, msg):
        if msg.assigned_robot_id != self.robot_id:
            return
        
        # 处理分配的任务
        self.get_logger().info(f'Received task to explore area around {msg.center_point}')
        # ... 任务处理逻辑 ...
```

### 6. 多机器人系统的调试与监控
多机器人系统的复杂性使得调试和监控变得尤为重要。在ROS2中，有多种工具和方法可以帮助开发者进行调试和监控。

### 6.1 分布式日志系统
在多机器人系统中，日志收集和分析是至关重要的：
```python
class DistributedLogger(Node):
    def __init__(self):
        super().__init__('distributed_logger')
        self.robot_id = self.declare_parameter('robot_id', 'central').value
        
        # 日志订阅
        self.log_subscription = self.create_subscription(
            LogMessage, '/fleet/logs', self.log_callback, 10)
        
        # 如果是中央日志节点
        if self.robot_id == 'central':
            # 创建日志文件
            self.log_file = open('fleet_logs.txt', 'a')
            self.get_logger().info('Central logger started')
        else:
            # 创建日志发布者
            self.log_publisher = self.create_publisher(
                LogMessage, '/fleet/logs', 10)
            
            # 定期发送心跳
            self.heartbeat_timer = self.create_timer(1.0, self.send_heartbeat)
    
    def log_callback(self, msg):
        if self.robot_id == 'central':
            # 将日志写入文件
            timestamp = self.get_clock().now().to_msg()
            log_entry = f"{timestamp.sec}.{timestamp.nanosec}: [{msg.robot_id}] [{msg.level}] {msg.message}\n"
            self.log_file.write(log_entry)
            self.log_file.flush()
    
    def send_heartbeat(self):
        if self.robot_id != 'central':
            msg = LogMessage()
            msg.robot_id = self.robot_id
            msg.level = 'INFO'
            msg.message = 'Heartbeat'
            self.log_publisher.publish(msg)
    
    def log_info(self, message):
        if self.robot_id != 'central':
            msg = LogMessage()
            msg.robot_id = self.robot_id
            msg.level = 'INFO'
            msg.message = message
            self.log_publisher.publish(msg)
    
    def log_warning(self, message):
        if self.robot_id != 'central':
            msg = LogMessage()
            msg.robot_id = self.robot_id
            msg.level = 'WARNING'
            msg.message = message
            self.log_publisher.publish(msg)
    
    def log_error(self, message):
        if self.robot_id != 'central':
            msg = LogMessage()
            msg.robot_id = self.robot_id
            msg.level = 'ERROR'
            msg.message = message
            self.log_publisher.publish(msg)
```

### 6.2 多机器人可视化工具
在多机器人系统中，可视化是至关重要的，可以使用ROS2的可视化工具，如`rqt`和`rviz`，来监控和调试系统。
```python
class FleetVisualizer(Node):
    def __init__(self):
        super().__init__('fleet_visualizer')
        self.robots = {}
        
        # 订阅机器人状态
        self.status_sub = self.create_subscription(
            RobotStatus, '/fleet/status', self.status_callback, 10)
        
        # 创建可视化标记发布者
        self.marker_pub = self.create_publisher(
            MarkerArray, '/fleet/visualization', 10)
        
        # 定期更新可视化
        self.vis_timer = self.create_timer(0.5, self.update_visualization)
    
    def status_callback(self, msg):
        robot_id = msg.robot_id
        position = msg.position
        status = msg.status
        
        # 更新机器人信息
        self.robots[robot_id] = {
            'position': position,
            'status': status,
            'last_update': self.get_clock().now()
        }
    
    def update_visualization(self):
        marker_array = MarkerArray()
        
        # 为每个机器人创建标记
        for robot_id, info in self.robots.items():
            # 创建机器人位置标记
            marker = Marker()
            marker.header.frame_id = "map"
            marker.header.stamp = self.get_clock().now().to_msg()
            marker.ns = "fleet"
            marker.id = int(robot_id)
            marker.type = Marker.CUBE
            marker.action = Marker.ADD
            
            # 设置位置
            marker.pose.position.x = info['position'][0]
            marker.pose.position.y = info['position'][1]
            marker.pose.position.z = 0.1
            
            # 设置方向（默认无旋转）
            marker.pose.orientation.w = 1.0
            
            # 设置大小
            marker.scale.x = 0.5
            marker.scale.y = 0.5
            marker.scale.z = 0.2
            
            # 根据状态设置颜色
            if info['status'] == 'idle':
                # 空闲：蓝色
                marker.color.r = 0.0
                marker.color.g = 0.0
                marker.color.b = 1.0
            elif info['status'] == 'moving':
                # 移动：绿色
                marker.color.r = 0.0
                marker.color.g = 1.0
                marker.color.b = 0.0
            elif info['status'] == 'busy':
                # 忙碌：黄色
                marker.color.r = 1.0
                marker.color.g = 1.0
                marker.color.b = 0.0
            elif info['status'] == 'error':
                # 错误：红色
                marker.color.r = 1.0
                marker.color.g = 0.0
                marker.color.b = 0.0
            else:
                # 其他：灰色
                marker.color.r = 0.5
                marker.color.g = 0.5
                marker.color.b = 0.5
            
            marker.color.a = 1.0  # 不透明度
            marker.lifetime = Duration(seconds=1, nanoseconds=0).to_msg()
            
            marker_array.markers.append(marker)
            
            # 添加机器人ID文本标记
            text_marker = Marker()
            text_marker.header.frame_id = "map"
            text_marker.header.stamp = self.get_clock().now().to_msg()
            text_marker.ns = "fleet_labels"
            text_marker.id = int(robot_id) + 1000  # 避免ID冲突
            text_marker.type = Marker.TEXT_VIEW_FACING
            text_marker.action = Marker.ADD
            
            # 设置位置（稍微高于机器人）
            text_marker.pose.position.x = info['position'][0]
            text_marker.pose.position.y = info['position'][1]
            text_marker.pose.position.z = 0.5
            
            # 设置方向
            text_marker.pose.orientation.w = 1.0
            
            # 设置文本
            text_marker.text = f"Robot {robot_id}: {info['status']}"
            
            # 设置大小
            text_marker.scale.z = 0.2  # 文本高度
            
            # 设置颜色（白色）
            text_marker.color.r = 1.0
            text_marker.color.g = 1.0
            text_marker.color.b = 1.0
            text_marker.color.a = 1.0
            
            text_marker.lifetime = Duration(seconds=1, nanoseconds=0).to_msg()
            
            marker_array.markers.append(text_marker)
        
        # 发布标记数组
        self.marker_pub.publish(marker_array)
```

### 6.3 性能监控和分析
在多机器人系统中，性能监控和分析是至关重要的，可以使用ROS2的性能监控工具，如`rqt`和`ros2 perf`，来监控和调试系统。
```python
class PerformanceMonitor(Node):
    def __init__(self):
        super().__init__('performance_monitor')
        self.robot_stats = {}
        
        # 订阅机器人状态
        self.status_sub = self.create_subscription(
            RobotStatus, '/fleet/status', self.status_callback, 10)
        
        # 订阅任务完成消息
        self.task_sub = self.create_subscription(
            TaskCompletion, '/fleet/task_completions', self.task_callback, 10)
        
        # 定期生成性能报告
        self.report_timer = self.create_timer(60.0, self.generate_report)
        
        # 性能指标服务
        self.metrics_service = self.create_service(
            GetPerformanceMetrics, 'get_performance_metrics', 
            self.handle_metrics_request)
    
    def status_callback(self, msg):
        robot_id = msg.robot_id
        timestamp = self.get_clock().now()
        
        if robot_id not in self.robot_stats:
            self.robot_stats[robot_id] = {
                'status_history': [],
                'tasks_completed': 0,
                'total_task_time': 0.0,
                'idle_time': 0.0,
                'last_status': '',
                'last_status_time': timestamp
            }
        
        # 记录状态变化
        if msg.status != self.robot_stats[robot_id]['last_status']:
            # 计算上一个状态的持续时间
            duration = (timestamp - self.robot_stats[robot_id]['last_status_time']).nanoseconds / 1e9
            
            # 如果上一个状态是空闲，累计空闲时间
            if self.robot_stats[robot_id]['last_status'] == 'idle':
                self.robot_stats[robot_id]['idle_time'] += duration
            
            # 记录状态历史
            self.robot_stats[robot_id]['status_history'].append({
                'status': self.robot_stats[robot_id]['last_status'],
                'duration': duration,
                'start_time': self.robot_stats[robot_id]['last_status_time'],
                'end_time': timestamp
            })
            
            # 更新当前状态
            self.robot_stats[robot_id]['last_status'] = msg.status
            self.robot_stats[robot_id]['last_status_time'] = timestamp
    
    def task_callback(self, msg):
        robot_id = msg.robot_id
        task_duration = msg.completion_time - msg.start_time  # 秒
        
        if robot_id in self.robot_stats:
            self.robot_stats[robot_id]['tasks_completed'] += 1
            self.robot_stats[robot_id]['total_task_time'] += task_duration
    
    def generate_report(self):
        self.get_logger().info("=== Fleet Performance Report ===")
        
        total_tasks = sum(stats['tasks_completed'] for stats in self.robot_stats.values())
        total_robots = len(self.robot_stats)
        
        self.get_logger().info(f"Total robots: {total_robots}")
        self.get_logger().info(f"Total tasks completed: {total_tasks}")
        
        if total_robots > 0:
            avg_tasks_per_robot = total_tasks / total_robots
            self.get_logger().info(f"Average tasks per robot: {avg_tasks_per_robot:.2f}")
        
        # 计算每个机器人的指标
        for robot_id, stats in self.robot_stats.items():
            tasks_completed = stats['tasks_completed']
            
            self.get_logger().info(f"\nRobot {robot_id}:")
            self.get_logger().info(f"  Tasks completed: {tasks_completed}")
            
            if tasks_completed > 0:
                avg_task_time = stats['total_task_time'] / tasks_completed
                self.get_logger().info(f"  Average task time: {avg_task_time:.2f} seconds")
            
            # 计算空闲时间百分比
            total_monitored_time = sum(entry['duration'] for entry in stats['status_history'])
            if total_monitored_time > 0:
                idle_percentage = (stats['idle_time'] / total_monitored_time) * 100
                self.get_logger().info(f"  Idle time: {idle_percentage:.2f}%")
        
        self.get_logger().info("===============================")
    
    def handle_metrics_request(self, request, response):
        # 处理获取性能指标的服务请求
        robot_id = request.robot_id
        
        if robot_id in self.robot_stats:
            stats = self.robot_stats[robot_id]
            
            response.tasks_completed = stats['tasks_completed']
            
            if stats['tasks_completed'] > 0:
                response.average_task_time = stats['total_task_time'] / stats['tasks_completed']
            
            total_monitored_time = sum(entry['duration'] for entry in stats['status_history'])
            if total_monitored_time > 0:
                response.idle_time_percentage = (stats['idle_time'] / total_monitored_time) * 100
            
            response.success = True
        else:
            response.success = False
            response.error_message = f"No data available for robot {robot_id}"
        
        return response
```

### 6.4 分布式调试工具
ROS2提供了多种工具来调试多机器人系统：
```bash
# 查看网络中的节点
$ ros2 node list

# 查看节点之间的通信
$ ros2 topic list
$ ros2 topic info /fleet/status

# 监听特定话题
$ ros2 topic echo /fleet/status

# 查看服务
$ ros2 service list

# 查看参数
$ ros2 param list

# 查看节点信息
$ ros2 node info /fleet_monitor
```

### 6.5 总结
多机器人系统开发需要考虑多个方面，包括系统架构、通信设计、任务分配、状态管理、性能监控和分布式调试。通过合理的设计和工具使用，可以构建高效、可靠的多机器人系统。